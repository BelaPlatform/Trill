;;*****************************************************************************
;;*****************************************************************************
;;  FILENAME: CSD.asm
;;  Version: 2.10, Updated on 2012/9/21 at 11:56:9
;;  Generated by PSoC Designer 5.4.3191
;;
;;  DESCRIPTION: CSD User Module software implementation file.
;;-----------------------------------------------------------------------------
;;  Copyright (c) Cypress Semiconductor 2012. All Rights Reserved.
;;*****************************************************************************
;;*****************************************************************************

include "m8c.inc"
include "memory.inc"
include "GlobalParams.inc"
include "CSD.inc"

;-----------------------------------------------
;  Global Labels
;-----------------------------------------------

; Exported functions
export _CSD_Start
export  CSD_Start
export _CSD_Stop
export  CSD_Stop
export _CSD_Resume
export  CSD_Resume
export _CSD_SetScanMode
export  CSD_SetScanMode
export _CSD_ClearSensors
export  CSD_ClearSensors
export _CSD_wReadSensor
export  CSD_wReadSensor
export _CSD_wGetPortPin
export  CSD_wGetPortPin
export _CSD_EnableSensor
export  CSD_EnableSensor
export _CSD_DisableSensor
export  CSD_DisableSensor
export _CSD_ScanSensor
export  CSD_ScanSensor
export _CSD_ScanAllSensors
export  CSD_ScanAllSensors
export _CSD_SetIdacValue
export  CSD_SetIdacValue
export _CSD_SetPrescaler
export  CSD_SetPrescaler
IF (CSD_AUTOCAL_ENABLE)
  export _CSD_CalibrateSensors
  export  CSD_CalibrateSensors
IF (CSD_SLIDERS_EXIST)
  export _CSD_SetSliderIdac
  export  CSD_SetSliderIdac
ENDIF
ENDIF

; Exported variables
export  CSD_bSensorNum
export _CSD_bSensorNum
export  CSD_waSnsResult
export _CSD_waSnsResult

export  CSD_bIdacValue
export _CSD_bIdacValue

export  CSD_bADCStatus
export _CSD_bADCStatus

export  CSD_wADC_Result
export _CSD_wADC_Result

IF (CSD_AUTOCAL_ENABLE)
export _CSD_baDAC
export  CSD_baDAC
ENDIF

AREA bss

;@PSoC_UserCode_INIT@ (Do not change this line.)
;---------------------------------------------------
; Insert your custom declarations below this banner
;---------------------------------------------------

;------------------------
; User Includes
;------------------------


;------------------------
; User Constant Definitions
;------------------------


;------------------------
; User Variable Allocation
;------------------------


;---------------------------------------------------
; Insert your custom declarations above this banner
;---------------------------------------------------
;@PSoC_UserCode_END@ (Do not change this line.)


;-----------------------------------------------
; Variable Allocation
;-----------------------------------------------
AREA bss
_CSD_waSnsResult:                               ; Current raw results
 CSD_waSnsResult:                       BLK  (2*CSD_TotalSensorCount)

AREA InterruptRAM (RAM, REL, CON)

 CSD_wADC_Result:
_CSD_wADC_Result:                       BLK  2

 CSD_bADCStatus:
_CSD_bADCStatus:                        BLK  1

 CSD_bBitMask:                          BLK  1  ; Temp bitmask byte
_CSD_bSensorNum:                                ; Current sensor to scan
 CSD_bSensorNum:                        BLK  1

 CSD_bIdacValue:
_CSD_bIdacValue:                        BLK  1
 CSD_bResolution:                       BLK  1
 CSD_bScanSpeed:                        BLK  1
 CSD_bPrescaler:                        BLK  1
 CSD_bScanCnt:                          BLK  1

IF (CSD_AUTOCAL_ENABLE)
 _CSD_baDAC:                                     ; iDAC calibration values
  CSD_baDAC:                            BLK  CSD_TotalSensorCount
  CSD_wTmp1:                            BLK 2
  CSD_wTmp2:                            BLK 2
ENDIF

AREA UserModules (ROM, REL, CON)

LSB:  equ  1
MSB:  equ  0

.LITERAL

CSD_PRS_CR_Table:
  db    0x98, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97  ;  Values for PRS_CR reg initialization

CSD_MUX_Table:                                  ; Analog Mux Enables Register address
  db    MUX_CR0, MUX_CR1, MUX_CR2, MUX_CR3, MUX_CR4

CSD_MaxADC_Table:                               ; High (2^resolution-1)
  DB    0x00, 0x01, 0x03, 0x07, 0x0F, 0x1F, 0x3F, 0x7F, 0xFF

.ENDLITERAL

.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: CSD_Start(void)
;
;  DESCRIPTION:
;  Connects external cap; sets up comparator
;  disables all possible analog mux bus
;  connections; shunts all sensor pins to ground.
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;    None
;
;  RETURNS:      None.
;  SIDE EFFECTS:
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16
;    functions.
;
 CSD_Start:
_CSD_Start:

   RAM_PROLOGUE RAM_USE_CLASS_4
   RAM_PROLOGUE RAM_USE_CLASS_3
   RAM_SETPAGE_CUR 0 ; direct access ram will always be in interrupt ram area

   RAM_SETPAGE_IDX >CSD_baSnsOnMask
   mov     X, (CSD_TotalSensorCount-1)/8
.NullingCycle:
   mov     [X + <CSD_baSnsOnMask], 0
   dec     X
   jnc     .NullingCycle

   RAM_SETPAGE_IDX >CSD_baSnsDebounce
   mov   X, (CSD_TotalSensorCount-1)
   mov   A, CSD_Debounce
.NullDbnc:
   mov   [X + CSD_baSnsDebounce], A
   dec   X
   jnc   .NullDbnc

   RAM_SETPAGE_IDX >CSD_baLowBaselineReset
   mov     A, CSD_LowBaselineReset
   mov     X, CSD_TotalSensorCount-1
.InitCycle:
   mov     [X + <CSD_baLowBaselineReset], A
   dec     X
   jnc     .InitCycle

   RAM_EPILOGUE RAM_USE_CLASS_3

    mov     [CSD_bNoiseThreshold], CSD_NOISE_THRESHOLD
    mov     [CSD_bNegativeNoiseThreshold], CSD_NEGATIVE_NOISE_THRESHOLD
    mov     [CSD_bBaselineUpdateThreshold], CSD_BASELINE_UPDATE_THRESHOLD
    mov     [CSD_bHysteresis], CSD_HYSTERESIS
    mov     [CSD_bDebounce], CSD_Debounce
    mov     [CSD_bLowBaselineReset], CSD_LowBaselineReset

    mov     [CSD_bPrescaler], CSD_PRESCALER
    mov     [CSD_bIdacValue], CSD_IDAC

IF (CSD_CAPACITOR_PIN & CSD_CAPACITOR_P0_1)
    or      reg[AMUXCFG], 0x0D      ; Capacitor on P0.1 + internal cap
    mov     X, 00h                  ; connect modulator capacitor
    mov     A, 02h
    call    CSD_EnableSensor
ENDIF
IF (CSD_CAPACITOR_PIN & CSD_CAPACITOR_P0_3)
    or      reg[AMUXCFG], 0x0E		; Capacitor on P0.3 + internal cap
    mov     X, 00h                  ; connect modulator capacitor
    mov     A, 08h
    call    CSD_EnableSensor
ENDIF
IF (CSD_CAPACITOR_PIN)
ELSE
    or      reg[AMUXCFG], 0x0C		; Enable internal cap
ENDIF

IF  (CSD_SHIELD & CSD_SHIELD_P0_7)
    M8C_SetBank1
    or      reg[OUT_P0], 0xC0         ; Enable CapSense output in OUT_P0
    M8C_SetBank0
ENDIF
IF  (CSD_SHIELD & CSD_SHIELD_P1_2)
    M8C_SetBank1
    or      reg[OUT_P1], 0x0C         ; Enable CapSense output in OUT_P1
    M8C_SetBank0
ENDIF

    mov     A, CSD_PRESCALER
    index   CSD_PRS_CR_Table
    or      A, CSD_PRS_RES
    mov	    reg[CSD_PRS_CR_REG], A  ; Set PRS resolution and Prescaler value
    mov	    reg[CS_CR0], (0x08 | CSD_PRCH_SRC)   ; Initialize CSD mode and select clock source
    or	    reg[CS_CR2], 0x04    ;Enable precharge switches on analog bus
    mov	    reg[CS_CR3], 0x50 | 0x20    ; Set VREF to 1V, Enable and connect it to bus
    or      reg[CMP_CR0], 0x01   ; Enable Comparator 0
    
    M8C_EnableIntMask    CSD_INT_REG, CSD_INT_MASK ; Enable the timer's interrupt

IF (CSD_AUTOCAL_ENABLE)
    mov  A, CSD_FAST_SPEED
    mov  X, CSD_CALIBRATION_RESOLUTION    ; Set calibration scan Resolution
    call CSD_SetScanMode
    call CSD_ClearSensors                             ; Loop through all sensors and deactivate them
    mov  X, CSD_IDAC_CALIBRATION_MSB                  ; Calibrate to 85% of calibration resolution scan
    mov  A, CSD_IDAC_CALIBRATION_LSB
    call    CSD_CalibrateSensors
IF (CSD_SLIDERS_EXIST)
    call    CSD_SetSliderIdac
ENDIF

ENDIF

    mov     A, CSD_SCANNING_SPEED
    mov     X, CSD_RESOLUTION
    call    CSD_SetScanMode

    call    CSD_ClearSensors                          ; Loop through all sensors and deactivates them



    RAM_EPILOGUE RAM_USE_CLASS_4
    ret
.ENDSECTION

.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: CSD_SetPrescaler
;
;  DESCRIPTION:
;  Sets the prescaler ratio and determines the precharge switch output frequency
;  INPUT:
;  A - BYTE bPrescaler  - new prescaler value. Allowed values are:
;     CSD_PRESCALER_1      0x00
;     CSD_PRESCALER_2      0x01
;     CSD_PRESCALER_4      0x02
;     CSD_PRESCALER_8      0x03
;     CSD_PRESCALER_16     0x04
;     CSD_PRESCALER_32     0x05
;     CSD_PRESCALER_64     0x06
;     CSD_PRESCALER_128    0x07
;     CSD_PRESCALER_256    0x08
;
;  RETURNS:      None.
;
;-----------------------------------------------------------------------------
_CSD_SetPrescaler:
 CSD_SetPrescaler:

    RAM_PROLOGUE RAM_USE_CLASS_4
    RAM_SETPAGE_CUR  0

    cmp     A, 0x09
    jc      .ValueOk
    mov     A, 0x08
.ValueOk:
    mov     [CSD_bPrescaler], A
    index   CSD_PRS_CR_Table
    or      A, CSD_PRS_RES
    mov	    reg[CSD_PRS_CR_REG], A  ; Set PRS resolution and Prescaler value
    mov     A, [CSD_bScanSpeed]
    mov     X, [CSD_bResolution]
    call    CSD_SetScanMode
    RAM_EPILOGUE RAM_USE_CLASS_4
    ret
.ENDSECTION

.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: CSD_SetScanMode
;
;  DESCRIPTION:
;  Sets Capsense clock and Timer value accordig to required Scan Speed and Resolution
;  INPUT:
;  A - BYTE bSpeed  - scan speed code (see  Constants for Scan Speed values)
;  X - BYTE bResolution - resolution [9..16]
;
;  RETURNS:      None.
;
;-----------------------------------------------------------------------------
_CSD_SetScanMode:
 CSD_SetScanMode:

    RAM_PROLOGUE RAM_USE_CLASS_4
    RAM_SETPAGE_CUR  0

    and     A, 0x03                                 ; clear unused bits
    mov     [CSD_bScanSpeed], A

    asl     A
    asl     A
    asl     A
    asl     A
    asl     A

    or      A, 0x80                                  ; Set Chain bit
    mov     reg[CS_CR1], A                           ; Set ClkSel bits according to selected ScanSpeed

    mov     A, X                                    ; A := Resolution
    dec     A
    and     A, 0x0F                                 ; clear unused bits
    or      A, 0x08                                 ; be sure the rsolution is in 9..16 range
    inc     A
    mov     [CSD_bResolution], A

    sub     A, [CSD_bPrescaler]
    add     A, [CSD_bScanSpeed]

.L0:
    mov     X, A
    mov     A, 0
    mov     [CSD_bBitMask], A
    mov     [CSD_bScanCnt], A
.L1:
    or      A, 1
    dec     X
    jz      .L2
    asl     A
    rlc     [CSD_bBitMask]
    rlc     [CSD_bScanCnt]
    jmp     .L1

.L2:
    mov     reg[CSD_DATA0_REG], A
    mov     A, [CSD_bBitMask]
    mov     reg[CSD_DATA1_REG], A

    RAM_EPILOGUE RAM_USE_CLASS_4
    ret

.ENDSECTION


.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: CSD_SetIdacValue
;
;  DESCRIPTION:
;
;  INPUT:
;  A - BYTE bIdacValue
;
;  RETURNS:      None.
;  SIDE EFFECTS:
;
;-----------------------------------------------------------------------------
_CSD_SetIdacValue:
 CSD_SetIdacValue:

    RAM_PROLOGUE RAM_USE_CLASS_4
    RAM_SETPAGE_CUR  0
    mov     [CSD_bIdacValue], A
    RAM_EPILOGUE RAM_USE_CLASS_4
    ret
.ENDSECTION

.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: CSD_ClearSensors(void)
;
;  DESCRIPTION:
;    Clears all sensor connections to the analog mux bus and shunts all sensor
;    pins to ground.
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:    None.
;  RETURNS:      None
;  SIDE EFFECTS:
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16
;    functions.
;
 CSD_ClearSensors:
_CSD_ClearSensors:
   RAM_PROLOGUE RAM_USE_CLASS_4
   mov   A,CSD_TotalSensorCount
   dec   A
.InitLoop:                             ; Loop through all sensors and deactivate
   push  A
   call  CSD_wGetPortPin
   call  CSD_DisableSensor
   pop   A
   dec   A
   jnc   .InitLoop
   RAM_EPILOGUE RAM_USE_CLASS_4
   ret
.ENDSECTION

.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: CSD_Stop(void)
;
;  DESCRIPTION:
;
;  Disables the CapSense interrupt, disconnects the external capacitor, disables
;  internal capacitor, disbales precharge switching, disconnects IDAC, disconnects VRef buffer
;  disables PRS
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:    None.
;  RETURNS:      Nothing.
;  SIDE EFFECTS:
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16
;    functions.
;
 CSD_Stop:
_CSD_Stop:
    RAM_PROLOGUE RAM_USE_CLASS_1
    M8C_DisableIntMask    CSD_INT_REG, CSD_INT_MASK ; Disable the CapSense Timer interrupt
    M8C_SetBank1
IF (CSD_CAPACITOR_PIN & CSD_CAPACITOR_P0_1)
   and reg[MUX_CR0], ~02h		;Disconnect external capacitor
ENDIF
IF (CSD_CAPACITOR_PIN & CSD_CAPACITOR_P0_3)
   and reg[MUX_CR0], ~08h		;Disconnect external capacitor
ENDIF
    M8C_SetBank0
    and     reg[AMUXCFG], ~0x0c		; Disconnect internal capacitor
    and     reg[CS_CR2], ~0x04		; Disable precharge switching and disconnect IDAC
    and     reg[CS_CR0], ~0x08		; Disable CSD mode
    mov     reg[CS_CR3], 0			; Power down and disconnect VRef Buffer
    mov	    reg[CSD_PRS_CR_REG], 0     ; Disable PRS
    
    RAM_EPILOGUE RAM_USE_CLASS_1
    ret
.ENDSECTION

.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: CSD_Resume(void)
;
;  DESCRIPTION:
;
;    Resumes CSD operation after Stop() call
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:    None.
;  RETURNS:      Nothing.
;  SIDE EFFECTS:
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16
;    functions.
;
 CSD_Resume:
_CSD_Resume:
    RAM_PROLOGUE RAM_USE_CLASS_4
    RAM_SETPAGE_CUR 0

    mov	    reg[CS_CR3], 0x50  		; Power up VRef Buffer
    mov     A, [CSD_bPrescaler]
    index   CSD_PRS_CR_Table
    or      A, CSD_PRS_RES
    mov	    reg[CSD_PRS_CR_REG], A  ; Set PRS resolution and Prescaler value

IF (CSD_CAPACITOR_PIN & CSD_CAPACITOR_P0_1)
    or      reg[AMUXCFG], 0x0D      ; Capacitor on P0.1 + internal cap
    mov     X, 00h                  ; connect modulator capacitor
    mov     A, 02h
    call    CSD_EnableSensor
ENDIF
IF (CSD_CAPACITOR_PIN & CSD_CAPACITOR_P0_3)
    or      reg[AMUXCFG], 0x0E		; Capacitor on P0.3 + internal cap
    mov     X, 00h                  ; connect modulator capacitor
    mov     A, 08h
    call    CSD_EnableSensor
ENDIF
IF (CSD_CAPACITOR_PIN)
ELSE
    or      reg[AMUXCFG], 0x0C		; Enable internal cap
ENDIF

    or	    reg[CS_CR3], 0x20		; Connect VRef Buffer
    or      reg[CS_CR2], 0x04		; Enable precharge switching and reconnect iDAC
    or      reg[CS_CR0], 0x08		; Enable CSD mode
    
    M8C_EnableIntMask    CSD_INT_REG, CSD_INT_MASK ; Enable the CapSense Timer interrupt
    RAM_EPILOGUE RAM_USE_CLASS_4
    ret
.ENDSECTION

.LITERAL
 CSD_Sensor_Table2:
_CSD_Sensor_Table2:
	dw	0x0408	// Port 4 Bit 3
	dw	0x0202	// Port 2 Bit 1
	dw	0x0208	// Port 2 Bit 3
	dw	0x0220	// Port 2 Bit 5
	dw	0x0008	// Port 0 Bit 3
	dw	0x0020	// Port 0 Bit 5
	dw	0x0080	// Port 0 Bit 7
	dw	0x0120	// Port 1 Bit 5
	dw	0x0201	// Port 2 Bit 0
	dw	0x0404	// Port 4 Bit 2
	dw	0x0401	// Port 4 Bit 0
	dw	0x0340	// Port 3 Bit 6
	dw	0x0310	// Port 3 Bit 4
	dw	0x0304	// Port 3 Bit 2
	dw	0x0301	// Port 3 Bit 0
	dw	0x0040	// Port 0 Bit 6
	dw	0x0010	// Port 0 Bit 4
	dw	0x0004	// Port 0 Bit 2
	dw	0x0001	// Port 0 Bit 0
	dw	0x0240	// Port 2 Bit 6
	dw	0x0210	// Port 2 Bit 4
	dw	0x0204	// Port 2 Bit 2
	dw	0x0280	// Port 2 Bit 7
	dw	0x0402	// Port 4 Bit 1
	dw	0x0380	// Port 3 Bit 7
	dw	0x0320	// Port 3 Bit 5
	dw	0x0308	// Port 3 Bit 3
	dw	0x0302	// Port 3 Bit 1
	dw	0x0180	// Port 1 Bit 7
	dw	0x0108	// Port 1 Bit 3

.ENDLITERAL


.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: CSD_wGetPortPin(BYTE bSensor)
;
;  DESCRIPTION:
;      Returns the port and pin mask from a given key number.  This function
;      uses the table CSD_Sensor_Table to retreive this
;      information.
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;        A => Sensor Number  ( 0 to n )
;  RETURNS:
;        A  <=  Sensor Bitmap
;        X  <=  Port Number
;
;  SIDE EFFECTS:
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16
;    functions.
;
 CSD_wGetPortPin:
_CSD_wGetPortPin:

  RAM_PROLOGUE RAM_USE_CLASS_1
   asl    A                                      ; multiply key by 2 since table is 2 bytes per key
   mov    X,A                                    ; Copy index*2 in x for next value
   index  CSD_Sensor_Table2                      ; A contains the port value
   swap   A,X                                    ; Place port value in X and index*2 in A
   inc    A                                      ; Advance to next value (bitMask)
   index  CSD_Sensor_Table2                      ; A contains bitMask, X has port number

   RAM_EPILOGUE RAM_USE_CLASS_1
   ret

.ENDSECTION


.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: CSD_EnableSensor(BYTE bSensorMask, BYTE bPort)
;
;  DESCRIPTION:
;    Configures sensor to be an input to be measured during next measurement
;    cycle; places sensor pin's drive mode in Analog Hi-Z mode and connects
;    to the analog mux bus.
;
;    This function does not do anything with the previous sensor.
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;          X =>  Port Number for given sensor
;          A =>  Bit mask for given sensor
;
;  RETURNS:      none
;
;  SIDE EFFECTS:
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16
;    functions.
;
 CSD_EnableSensor:
_CSD_EnableSensor:
	RAM_PROLOGUE RAM_USE_CLASS_4
    RAM_SETPAGE_CUR 0 ; direct access ram will always be in interrupt ram area

    ; Setup Mux for sensor
    mov  [CSD_bBitMask],A                                  ; Store bit mask in temp location
    push X

    mov  A,X                                               ; Multiply port number by four for registor addresses
    asl  A
    asl  A
    mov  X,A                                               ; Restore Port address in X

    ; Set mode do 10 (Hi-Z Analog) and connect to analog mux bus
    M8C_SetBank1
    mov  A, reg[X+DM1_OFFSET]                              ; Set DM1 to 1
    or   A, [CSD_bBitMask]
    mov  reg[X+DM1_OFFSET], A
    xor  [CSD_bBitMask],FFh                                ; Invert bitmask
    mov  A, reg[X+DM0_OFFSET]                              ; Clear DM0 bit to 0
    and  A, [CSD_bBitMask]
    mov  reg[X+DM0_OFFSET], A
    xor  [CSD_bBitMask],FFh                                ; Invert bitmask to get original mask
    pop  A

    index CSD_MUX_Table
    mov  X, A
    mov  A, reg[X]
    or   A, [CSD_bBitMask]
    mov  reg[X], A
    M8C_SetBank0

	RAM_EPILOGUE RAM_USE_CLASS_4
    ret
.ENDSECTION

.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: CSD_DisableSensor(BYTE bMask, BYTE bPort)
;
;  DESCRIPTION:
;    Disconnects the desired sensor from the analog mux bus and shunts to
;    ground.
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;          X =>  Port Number for given sensor
;          A =>  Bit mask for given sensor
;
;  RETURNS:      none
;
;  SIDE EFFECTS:
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16
;    functions.
;
 CSD_DisableSensor:
_CSD_DisableSensor:
	RAM_PROLOGUE RAM_USE_CLASS_4
	RAM_SETPAGE_CUR 0 ; direct access ram will always be in interrupt ram area

    ; Disconnect sensor from mux
    push X                                       ; Store Port Number
    cpl  A                                       ; Invert bitmask
    mov  [CSD_bBitMask], A                       ; Store bit mask in temp location
   	M8C_SetBank1
    mov  A, X
    index  CSD_MUX_Table
    mov  X, A
    mov  A, reg[X]
    and  A, [CSD_bBitMask]
    mov  reg[X], A
   	M8C_SetBank0

    pop  A                                       ; restore Port Number
    asl  A
    asl  A
    mov  X, A                                    ; Restore Port address in X

    ; Set mode to 01 (Digital Strong)
   	M8C_SetBank1
    mov  A, reg[X+DM1_OFFSET]                    ; Set DM1 to 0
    and  A, [CSD_bBitMask]
    mov  reg[X+DM1_OFFSET], A
    xor  [CSD_bBitMask], FFh                     ; Invert bitmask back to normal
    mov  A, reg[X+DM0_OFFSET]                    ; Set DM0 bit to 1
    or   A, [CSD_bBitMask]
    mov  reg[X+DM0_OFFSET], A
	M8C_SetBank0

	RAM_EPILOGUE RAM_USE_CLASS_4
    ret
.ENDSECTION

.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: CSD_ScanSensor(BYTE bStrtIdx)
;
;  DESCRIPTION:
;  Uses the CapSense switching circuitry to charge to the starting voltage.
;  Then a fixed slope ramp is used to measure the starting voltage with a
;  16 bit timer.
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;      A  => Sensor Index
;
;  RETURNS:      None
;  SIDE EFFECTS:
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16
;    functions.
;
 CSD_ScanSensor:
_CSD_ScanSensor:
    RAM_PROLOGUE RAM_USE_CLASS_3
    RAM_SETPAGE_CUR 0

    mov     [CSD_bSensorNum], A

    mov     A, 0
    mov     [CSD_wADC_Result+MSB], A
    mov     [CSD_wADC_Result+LSB], A

IF (CSD_AUTOCAL_ENABLE)
    mov     A, [CSD_bSensorNum]
    mov     X, A
    RAM_SETPAGE_IDX >CSD_baDAC
    mov     A, [X+CSD_baDAC]
    mov     [CSD_bIdacValue], A
ENDIF

    or      reg[CS_CR0], 0x01           ; Start capsense block (enable AMUX bus regulation with iDAC)
    mov     A, [CSD_bIdacValue]
    mov     reg[IDAC_D], A              ; Turn on iDAC
    and     reg[CS_CR3], ~0x20          ; Disconnect VRef from AMUX bus
    mov	    A, [CSD_bSensorNum]	; Connect sensor to AMUX bus (switching is already enable in CSD_Start)
    call    CSD_wGetPortPin
    call    CSD_EnableSensor
    mov     X, [CSD_bScanCnt]          ; Slow and/or high resolution scan modes require several scans

.L0:

    mov     [CSD_bADCStatus], 0
    mov     reg[CS_CNTH], 0
    mov     reg[CS_CNTL], 0
    or      reg[CSD_CONFIG_REG], 0x01  ; Start timer - enable measurement
.L1:
    mov     A, [CSD_bADCStatus]
    jz      .L1                         ; Wait for timer's interrupt

    dec     X
    jnc     .L0                         ; Loop back to repeat scan if needed for slow and/or high resolution scan modes

    mov     A, [CSD_bSensorNum]    ; Disconnect sensor from AMUX bus
    call    CSD_wGetPortPin
    call    CSD_DisableSensor
    or      reg[CS_CR3], 0x20           ; Connect VRef to AMUX bus
    and     reg[CS_CR0], ~0x01          ; Stop capsense block
    mov     reg[IDAC_D], 0              ; Disable iDAC

    mov     A, 0xFF                     ; Result normalization - on touch raw count shall increase
    swap    A, [CSD_wADC_Result+LSB]
    sub     [CSD_wADC_Result+LSB], A
    mov     A, [CSD_bResolution]
    sub     A, 8
    index   CSD_MaxADC_Table
    swap    A, [CSD_wADC_Result+MSB]
    sbb     [CSD_wADC_Result+MSB], A
    jnc     .Cont
    mov     [CSD_wADC_Result+MSB], 0
    mov     [CSD_wADC_Result+LSB], 0

.Cont:
    mov     A, [CSD_bSensorNum]
    asl     A                          ; Multiply by two since results are INTs
    mov     X, A

    RAM_SETPAGE_IDX >CSD_waSnsResult
    mov     A, [CSD_wADC_Result + LSB] ; Store result in waSnsResult array
    mov     [X+(CSD_waSnsResult+LSB)], A
    mov     A, [CSD_wADC_Result + MSB]
    mov     [X+(CSD_waSnsResult+MSB)], A

    RAM_EPILOGUE RAM_USE_CLASS_3
    ret

.ENDSECTION

.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: CSD_ScanAllSensors(void)
;
;  DESCRIPTION:
;    Scans all sensors to find their raw count values
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:    None.
;  RETURNS:      None
;  SIDE EFFECTS:
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16
;    functions.
;
 CSD_ScanAllSensors:
_CSD_ScanAllSensors:
   RAM_PROLOGUE RAM_USE_CLASS_4
   mov   A,CSD_TotalSensorCount                       ; Check if key value in range.
   dec   A
.ScanLoop:                                            ; Loop through all sensors and scan
   push  A
   call  CSD_ScanSensor
   pop   A
   dec   A
   jnc   .ScanLoop
   RAM_EPILOGUE RAM_USE_CLASS_4
   ret
.ENDSECTION

.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: CSD_wReadSensor(BYTE bSensor)
;
;  DESCRIPTION:
;     Returns the sensor scan value in A (LSB) and X (MSB)
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;    A = Sensor number
;  RETURNS:
;    Scan value of sensor LSB in A and MSB in X
;  SIDE EFFECTS:
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to preserve their values across calls to fastcall16
;    functions.
;
 CSD_wReadSensor:
_CSD_wReadSensor:
   RAM_PROLOGUE RAM_USE_CLASS_3
   RAM_SETPAGE_IDX >CSD_waSnsResult
   asl   A                                            ; Multiply by two since results are INTs
   mov   X,A
   mov   A,[X+(CSD_waSnsResult+LSB)]
   mov   X,[X+(CSD_waSnsResult+MSB)]
   RAM_EPILOGUE RAM_USE_CLASS_3
   ret
.ENDSECTION

IF (CSD_AUTOCAL_ENABLE)
.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: CSD_CalibrateSensors(wLevel)
;
;  DESCRIPTION:
;   Adjusts iDAC current to obtain raw count near wLevel value.
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:    A - wLevel (LSB)
;                X - wLevel (MSB)
;  RETURNS:      None. Calibration setting are stored in the global array CSD_baDAC[]
;
;  SIDE EFFECTS:
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16
;    functions.
;
 CSD_CalibrateSensors:
_CSD_CalibrateSensors:
   RAM_PROLOGUE RAM_USE_CLASS_3
   RAM_SETPAGE_CUR 0

   mov   [CSD_wTmp1 + LSB], A
   mov   [CSD_wTmp1 + MSB], X

   mov   [CSD_bSensorNum], CSD_TotalSensorCount-1
.ScanLoop:                                           ; Loop through all sensors and scan
   RAM_SETPAGE_IDX >CSD_baDAC
   mov   X, [CSD_bSensorNum]
   mov   [X+CSD_baDAC], 80h
   mov   [CSD_wTmp2+LSB], 8
   mov   [CSD_wTmp2+MSB], 80h
.L0:
   mov   A, [CSD_bSensorNum]
   call  CSD_ScanSensor
   mov   A, [CSD_bSensorNum]
   call  CSD_ScanSensor

   RAM_PROLOGUE RAM_USE_CLASS_3                      ; Restore paging mode after function call
   mov   X, [CSD_bSensorNum]

   RAM_SETPAGE_IDX >CSD_baDAC
   mov   A, [CSD_wADC_Result+LSB]
   cmp   A, [CSD_wTmp1 + LSB]
   mov   A, [CSD_wADC_Result+MSB]
   sbb   A, [CSD_wTmp1 + MSB]                    ; if wADC_Result <= wLevel
   jnc   .L1
   mov   A, [CSD_wTmp2+MSB]                      ; below the target, clear the bit
   cpl   A
   and   [X+CSD_baDAC], A
.L1:
   asr   [CSD_wTmp2+MSB]                         ; above the target, keep the bit
   and   [CSD_wTmp2+MSB], ~80h
   mov   A, [CSD_wTmp2+MSB]
   or    [X+CSD_baDAC], A
   dec   [CSD_wTmp2+LSB]
   jnz   .L0

   dec   [CSD_bSensorNum]
   jnc   .ScanLoop

   RAM_EPILOGUE RAM_USE_CLASS_3
   ret
.ENDSECTION
IF(CSD_SLIDERS_EXIST)

.LITERAL
 CSD_Group_Table2:
_CSD_Group_Table2:
; Group Table:
;    Origin    Count    Diplex?    DivBtwSw(wholeMSB, wholeLSB, fractByte)
 db   0x0,      0x00,	 0x00,	 0x00,	 0x00,	 0x00 ; Buttons
 db   0x00,	    0x1E,	 0x00,	 0x00,	 0x46,	 0x96 ; Slider 1

.ENDLITERAL

.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: CSD_SetSliderIdac(void)
;
;  DESCRIPTION:
;   Sets iDAC current for slider elements to the highest for each slider group.
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:    None.
;  RETURNS:      None.
;
;  SIDE EFFECTS:
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16
;    functions.
;
 CSD_SetSliderIdac:
_CSD_SetSliderIdac:
   RAM_PROLOGUE RAM_USE_CLASS_3
   RAM_SETPAGE_CUR 0 ; direct access ram will always be in interrupt ram area
   RAM_SETPAGE_IDX >CSD_baDAC

   mov     A, CSD_SliderCount

.StartSliderAdjustment:
   push    A                                          ;Store Slider Count Index
   asl     A
   mov     [CSD_wTmp1+MSB], A
   asl     A
   add     A, [CSD_wTmp1+MSB]                         ;A contains Slider Count multiplied by 6
   mov     X, A
   index   CSD_Group_Table2                            ;Get the Slider Start Position
   mov     [CSD_wTmp2+LSB], A                         ;[CSD_wTmp2+LSB] contains the start of this slider group
   mov     [CSD_wTmp2+MSB], A
   mov     A, X
   inc     A                                          ;Increment to get the slider size
   index   CSD_Group_Table2
   add     [CSD_wTmp2+MSB], A                         ;[CSD_wTmp2+MSB] contains the end of this slider group

   mov     [CSD_bCurPos], 0                           ;[CSD_bCurPos] used as temp to store max iDAC setting found.  Clear variable.

   mov     A, [CSD_wTmp2+MSB]                         ;[CSD_wTmp2+MSB] contains the end of this slider group
.StartIDACSearch:
   push    A
   dec     A
   mov     X, A
   mov     A, [X+CSD_baDAC]
   cmp     A, [CSD_bCurPos]                           ;Is [CSD_baDAC+X] < [CSD_bCurPos]
   jc      .NoStore
   mov     [CSD_bCurPos], A                           ;Store current iDAC as highest
.NoStore:
   pop     A
   dec     A
   cmp     A, [CSD_wTmp2+LSB]
   jnz      .StartIDACSearch

   mov     A, [CSD_wTmp2+MSB]                         ;[CSD_wTmp2+MSB] contains the end of this slider group
.StartSetIDAC:
   push    A
   dec     A
   mov     X, A
   mov     A, [CSD_bCurPos]                           ;Set all iDAC settings to highest.
   mov     [X+CSD_baDAC], A
   pop     A
   dec     A
   cmp     A, [CSD_wTmp2+LSB]
   jnz      .StartSetIDAC

.EndSliderSdjustment:
   pop     A                                          ;Get the Slider Count Index
   dec     A
   jnz     .StartSliderAdjustment

   RAM_EPILOGUE RAM_USE_CLASS_3
   ret
.ENDSECTION
ENDIF

ENDIF
